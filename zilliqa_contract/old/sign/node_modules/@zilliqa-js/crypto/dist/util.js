"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var elliptic_1 = tslib_1.__importDefault(require("elliptic"));
var hash_js_1 = tslib_1.__importDefault(require("hash.js"));
var util_1 = require("@zilliqa-js/util");
var secp256k1 = elliptic_1.default.ec('secp256k1');
/**
 * getAddressFromPrivateKey
 *
 * takes a hex-encoded string (private key) and returns its corresponding
 * 20-byte hex-encoded address.
 *
 * @param {string} privateKey
 * @returns {string}
 */
exports.getAddressFromPrivateKey = function (privateKey) {
    var keyPair = secp256k1.keyFromPrivate(privateKey, 'hex');
    var pub = keyPair.getPublic(true, 'hex');
    return hash_js_1.default
        .sha256()
        .update(pub, 'hex')
        .digest('hex')
        .slice(24);
};
/**
 * getPubKeyFromPrivateKey
 *
 * takes a hex-encoded string (private key) and returns its corresponding
 * hex-encoded 33-byte public key.
 *
 * @param {string} privateKey
 * @returns {string}
 */
exports.getPubKeyFromPrivateKey = function (privateKey) {
    var keyPair = secp256k1.keyFromPrivate(privateKey, 'hex');
    return keyPair.getPublic(true, 'hex');
};
/**
 * compressPublicKey
 *
 * @param {string} publicKey - 65-byte public key, a point (x, y)
 *
 * @returns {string}
 */
exports.compressPublicKey = function (publicKey) {
    return secp256k1.keyFromPublic(publicKey, 'hex').getPublic(true, 'hex');
};
/**
 * getAddressFromPublicKey
 *
 * takes hex-encoded string and returns the corresponding address
 *
 * @param {string} pubKey
 * @returns {string}
 */
exports.getAddressFromPublicKey = function (publicKey) {
    return hash_js_1.default
        .sha256()
        .update(publicKey, 'hex')
        .digest('hex')
        .slice(24);
};
/**
 * toChecksumAddress
 *
 * takes hex-encoded string and returns the corresponding address
 *
 * @param {string} address
 * @returns {string}
 */
exports.toChecksumAddress = function (address) {
    address = address.toLowerCase().replace('0x', '');
    var hash = hash_js_1.default
        .sha256()
        .update(address, 'hex')
        .digest('hex');
    var v = new util_1.BN(hash, 'hex', 'be');
    var ret = '0x';
    for (var i = 0; i < address.length; i++) {
        if ('0123456789'.indexOf(address[i]) !== -1) {
            ret += address[i];
        }
        else {
            ret += v.and(new util_1.BN(2).pow(new util_1.BN(255 - 6 * i))).gte(new util_1.BN(1))
                ? address[i].toUpperCase()
                : address[i].toLowerCase();
        }
    }
    return ret;
};
/**
 * isValidChecksumAddress
 *
 * takes hex-encoded string and returns boolean if address is checksumed
 *
 * @param {string} address
 * @returns {boolean}
 */
exports.isValidChecksumAddress = function (address) {
    return (util_1.validation.isAddress(address.replace('0x', '')) &&
        exports.toChecksumAddress(address) === address);
};
/**
 * verifyPrivateKey
 *
 * @param {string|Buffer} privateKey
 * @returns {boolean}
 */
exports.verifyPrivateKey = function (privateKey) {
    var keyPair = secp256k1.keyFromPrivate(privateKey, 'hex');
    var result = keyPair.validate().result;
    return result;
};
//# sourceMappingURL=util.js.map