"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@zilliqa-js/core");
var crypto_1 = require("@zilliqa-js/crypto");
var util_1 = require("./util");
/**
 * Transaction
 *
 * Transaction is a functor. Its purpose is to encode the possible states a
 * Transaction can be in:  Confirmed, Rejected, Pending, or Initialised (i.e., not broadcasted).
 */
var Transaction = /** @class */ (function () {
    function Transaction(params, provider, status, toDS) {
        if (status === void 0) { status = 0 /* Initialised */; }
        if (toDS === void 0) { toDS = false; }
        this.code = '';
        this.data = '';
        // private members
        this.version = params.version;
        this.toAddr = params.toAddr.toLowerCase();
        this.nonce = params.nonce;
        this.pubKey = params.pubKey;
        this.amount = params.amount;
        this.code = params.code || '';
        this.data = params.data || '';
        this.signature = params.signature;
        this.gasPrice = params.gasPrice;
        this.gasLimit = params.gasLimit;
        this.receipt = params.receipt;
        // public members
        this.provider = provider;
        this.status = status;
        this.toDS = toDS;
    }
    /**
     * confirm
     *
     * constructs an already-confirmed transaction.
     *
     * @static
     * @param {BaseTx} params
     */
    Transaction.confirm = function (params, provider) {
        return new Transaction(params, provider, 2 /* Confirmed */);
    };
    /**
     * reject
     *
     * constructs an already-rejected transaction.
     *
     * @static
     * @param {BaseTx} params
     */
    Transaction.reject = function (params, provider) {
        return new Transaction(params, provider, 3 /* Rejected */);
    };
    Object.defineProperty(Transaction.prototype, "bytes", {
        get: function () {
            return util_1.encodeTransactionProto(this.txParams);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "senderAddress", {
        get: function () {
            if (!this.pubKey) {
                return '0'.repeat(40);
            }
            return crypto_1.getAddressFromPublicKey(this.pubKey);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "txParams", {
        get: function () {
            return {
                version: this.version,
                // TODO: do not strip 0x after implementation on core side
                toAddr: crypto_1.toChecksumAddress(this.toAddr).slice(2),
                nonce: this.nonce,
                pubKey: this.pubKey,
                amount: this.amount,
                gasPrice: this.gasPrice,
                gasLimit: this.gasLimit,
                code: this.code,
                data: this.data,
                signature: this.signature,
                receipt: this.receipt,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "payload", {
        get: function () {
            return {
                version: 0,
                toAddr: this.toAddr,
                nonce: this.nonce,
                pubKey: this.pubKey,
                amount: this.amount.toString(),
                gasPrice: this.gasPrice.toString(),
                gasLimit: this.gasLimit.toString(),
                code: this.code,
                data: this.data,
                signature: this.signature,
                receipt: this.receipt,
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * isPending
     *
     * @returns {boolean}
     */
    Transaction.prototype.isPending = function () {
        return this.status === 1 /* Pending */;
    };
    /**
     * isInitialised
     *
     * @returns {boolean}
     */
    Transaction.prototype.isInitialised = function () {
        return this.status === 0 /* Initialised */;
    };
    /**
     * isConfirmed
     *
     * @returns {boolean}
     */
    Transaction.prototype.isConfirmed = function () {
        return this.status === 2 /* Confirmed */;
    };
    /**
     * isRejected
     *
     * @returns {boolean}
     */
    Transaction.prototype.isRejected = function () {
        return this.status === 3 /* Rejected */;
    };
    /**
     * setProvider
     *
     * Sets the provider on this instance.
     *
     * @param {Provider} provider
     */
    Transaction.prototype.setProvider = function (provider) {
        this.provider = provider;
    };
    /**
     * setStatus
     *
     * Escape hatch to imperatively set the state of the transaction.
     *
     * @param {TxStatus} status
     * @returns {undefined}
     */
    Transaction.prototype.setStatus = function (status) {
        this.status = status;
        return this;
    };
    /**
     * confirmReceipt
     *
     * Similar to the Promise API. This sets the Transaction instance to a state
     * of pending. Calling this function kicks off a passive loop that polls the
     * lookup node for confirmation on the txHash.
     *
     * The polls are performed with a linear backoff:
     *
     * `const delay = interval * attempt`
     *
     * This is a low-level method that you should generally not have to use
     * directly.
     *
     * @param {string} txHash
     * @param {number} maxAttempts
     * @param {number} initial interval in milliseconds
     * @returns {Promise<Transaction>}
     */
    Transaction.prototype.confirm = function (txHash, maxAttempts, interval) {
        if (maxAttempts === void 0) { maxAttempts = core_1.GET_TX_ATTEMPTS; }
        if (interval === void 0) { interval = 1000; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var attempt, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.status = 1 /* Pending */;
                        attempt = 0;
                        _a.label = 1;
                    case 1:
                        if (!(attempt < maxAttempts)) return [3 /*break*/, 8];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.trackTx(txHash)];
                    case 3:
                        if (_a.sent()) {
                            return [2 /*return*/, this];
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        err_1 = _a.sent();
                        this.status = 3 /* Rejected */;
                        throw err_1;
                    case 5:
                        if (!(attempt + 1 < maxAttempts)) return [3 /*break*/, 7];
                        return [4 /*yield*/, util_1.sleep(interval * attempt)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        attempt++;
                        return [3 /*break*/, 1];
                    case 8:
                        this.status = 3 /* Rejected */;
                        throw new Error("The transaction is still not confirmed after " + maxAttempts + " attempts.");
                }
            });
        });
    };
    /**
     * map
     *
     * maps over the transaction, allowing for manipulation.
     *
     * @param {(prev: TxParams) => TxParams} fn - mapper
     * @returns {Transaction}
     */
    Transaction.prototype.map = function (fn) {
        var newParams = fn(this.txParams);
        this.setParams(newParams);
        return this;
    };
    Transaction.prototype.setParams = function (params) {
        this.version = params.version;
        this.toAddr = params.toAddr;
        this.nonce = params.nonce;
        this.pubKey = params.pubKey;
        this.amount = params.amount;
        this.code = params.code || '';
        this.data = params.data || '';
        this.signature = params.signature;
        this.gasPrice = params.gasPrice;
        this.gasLimit = params.gasLimit;
        this.receipt = params.receipt;
    };
    Transaction.prototype.trackTx = function (txHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.provider.send('GetTransaction', txHash)];
                    case 1:
                        res = _a.sent();
                        if (res.error) {
                            return [2 /*return*/, false];
                        }
                        this.id = res.result.ID;
                        this.receipt = tslib_1.__assign({}, res.result.receipt, { cumulative_gas: parseInt(res.result.receipt.cumulative_gas, 10) });
                        this.status =
                            this.receipt && this.receipt.success
                                ? 2 /* Confirmed */
                                : 3 /* Rejected */;
                        return [2 /*return*/, true];
                }
            });
        });
    };
    return Transaction;
}());
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map